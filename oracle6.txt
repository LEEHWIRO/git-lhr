SELECT R.A, R.B, R.C
     , S.C, S.D, S.E
FROM   R, S
WHERE R.C = S.C(+)
UNION
SELECT R.A, R.B, R.C
     , S.C, S.D, S.E
FROM   R, S
WHERE R.C(+) = S.C;

--ANSI 표준
SELECT R.A, R.B, R.C
     , S.C, S.D, S.E
FROM   R FULL OUTER JOIN S ON(R.C = S.C);

-- grant all on hr.employees to pc16; : hr.employees에게 모든 권한 부여

--집합(UNION)을 사용하려면
--열의 개수 동일, 대응되는 컬럼의 자료형이 동일
-- A UNION ALL B : 합집합, A INTERSECT B : 교집합(꼭 중복제거),
-- A MINUS B : A의 차집합, A UNION B : 모든자료 조회(단, 중복은 한번만)
SELECT MEM_ID, MEM_NAME
FROM   MEMBER
UNION ALL
SELECT TO_CHAR(EMPLOYEE_ID), LAST_NAME || FIRST_NAME
FROM   HR.EMPLOYEES;

SELECT T.MEM_NAME, T.MEM_JOB, T.MEM_MILEAGE
FROM
(SELECT A.MEM_NAME
     , A.MEM_JOB
     , A.MEM_MILEAGE
FROM   MEMBER A
WHERE  A.MEM_MILEAGE > 4000
UNION  --자동중복제거, 자동정렬
SELECT B.MEM_NAME
     , B.MEM_JOB
     , B.MEM_MILEAGE
FROM   MEMBER B
WHERE  MEM_JOB = '자영업') T
ORDER BY T.MEM_MILEAGE DESC;

SELECT A.MEM_NAME
     , A.MEM_JOB
     , A.MEM_MILEAGE
FROM   MEMBER A
WHERE  A.MEM_MILEAGE < 4000
UNION  ALL --모든데이터표시, 자동정렬
SELECT B.MEM_NAME
     , B.MEM_JOB
     , B.MEM_MILEAGE
FROM   MEMBER B
WHERE  MEM_JOB = '자영업';

SELECT A.MEM_NAME
     , A.MEM_JOB
     , A.MEM_MILEAGE
FROM   MEMBER A
WHERE  A.MEM_MILEAGE < 4000
INTERSECT --교집합, 자동정렬
SELECT B.MEM_NAME
     , B.MEM_JOB
     , B.MEM_MILEAGE
FROM   MEMBER B
WHERE  MEM_JOB = '자영업'
ORDER BY MEM_NAME ASC;

SELECT A.MEM_NAME
     , A.MEM_JOB
     , A.MEM_MILEAGE
FROM   MEMBER A
WHERE  A.MEM_MILEAGE < 4000
MINUS --차집합, 자동정렬
SELECT B.MEM_NAME
     , B.MEM_JOB
     , B.MEM_MILEAGE
FROM   MEMBER B
WHERE  MEM_JOB = '자영업'
ORDER BY MEM_NAME ASC;

--상품분류테이블, 상품테이블, 회원테이블의 자료수를  조회
SELECT 'LPROD' 테이블
     , '상품분류테이블' 테이블이름
     , COUNT(*) 자료수
FROM   LPROD
UNION
SELECT 'PROD' 테이블
     , '상품테이블' 테이블이름
     , COUNT(*) 자료수
FROM   PROD
UNION
SELECT 'MEMBER' 테이블
     , '회원테이블' 테이블이름
     , COUNT(*) 자료수
FROM   MEMBER;

--장바구니 테이블에서
--A)2005년도 4월에 판매한 상품과
--B)2005년도 6월에 판매된 상품 중
--A), B) 모두에 해당되는 상품
--ALIAS : 판매상품코드, 상품명
WITH T AS(
SELECT A.CART_PROD 판매상품코드
     , (SELECT B.PROD_NAME FROM PROD B WHERE A.CART_PROD = B.PROD_ID) 상품명
     , A.CART_NO
     , 'A' AS GUBUN
FROM   CART A
WHERE  SUBSTR(A.CART_NO,1,8) BETWEEN '20050401' AND '20050430'
UNION ALL
SELECT A.CART_PROD
     , (SELECT B.PROD_NAME FROM PROD B WHERE A.CART_PROD = B.PROD_ID)
     , A.CART_NO
     , 'B'
FROM   CART A
WHERE  A.CART_NO LIKE '200506%')
SELECT * FROM T WHERE T.GUBUN = 'B' ORDER BY T.상품명;

--INTERSECT 사용
SELECT DISTINCT A.CART_PROD CartProd
     , (SELECT B.PROD_NAME FROM PROD B WHERE A.CART_PROD = B.PROD_ID) ProdName
FROM   CART A
WHERE  SUBSTR(A.CART_NO,1,8) BETWEEN '20050401' AND '20050430'
INTERSECT
SELECT DISTINCT A.CART_PROD
     , (SELECT B.PROD_NAME FROM PROD B WHERE A.CART_PROD = B.PROD_ID)
FROM   CART A
WHERE  A.CART_NO LIKE '200506%';

--EXISTS, 교집합할때는 꼭 중복제거하자.
--EXIST를 이용하여 INTERSECT구현
--P302### 중에서 P302000012 여성 향수가 앞쪽 테이블에 없음
--EXISTS심경
--A와 B 집합 사이에 AND EXISTS를 작성하고
--B 집합을 괄호로 묶은 후
--B 집합에 조인조건을 적습니다
SELECT DISTINCT A.CART_PROD CartProd
     , (SELECT B.PROD_NAME FROM PROD B WHERE A.CART_PROD = B.PROD_ID) ProdName
FROM   CART A
WHERE  SUBSTR(A.CART_NO,1,8) BETWEEN '20050401' AND '20050430'
AND EXISTS(
SELECT DISTINCT C.CART_PROD
     , (SELECT D.PROD_NAME FROM PROD D WHERE C.CART_PROD = D.PROD_ID)
FROM   CART C
WHERE  C.CART_NO LIKE '200506%'
AND    C.CART_PROD = A.CART_PROD--조인조건(연결고리)
);
