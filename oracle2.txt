SELECT PROD_PRICE 변경전
     , LPAD(PROD_PRICE, 10, '*') 변경후 --왼쪽공백
     , RPAD(PROD_PRICE, 10, '*') 변경후 --오른쪽공백
FROM   PROD;

SELECT '<' || LTRIM('     AAA     ') || '>' "LTRIM1",    --좌측 공백제거
       '<' || LTRIM('Hello World', 'He') || '>' "LTRIM2",--왼쪽부터 'He' 문자를 찾아 하나 제거
FROM DUAL;

SELECT '<' || RTRIM('     A A A     ') || '>' "RTRIM1",  -- 우측 공백제거
       '<' || RTRIM('Hello World', 'ld') || '>' "RTRIM2" --우측부터 'He' 문자를 찾아 하나 제거
FROM DUAL;

SELECT '<' || TRIM('     AAA     ') || '>'  TRIM1,               --앞뒤 공백제거
       '<' || TRIM(LEADING 'a' FROM 'aaAaBaAaa') || '>'  TRIM2,  --앞 연속되는 a 제거
       '<' || TRIM(TRAILING 'a' FROM 'aaAaBaAaa') || '>'  TRIM3, --뒤 연속되는 a제거
       '<' || TRIM(BOTH 'a' FROM 'aaAaBaAaa') || '>'  TRIM4,     --앞뒤(양쪽) 연속되는 a제거
       '<' || TRIM( 'a' FROM 'aaAaBaAaa') || '>'  TRIM5          --앞뒤 연속되는 a제거
FROM SYS.DUAL; --DUAL : 가상의 테이블, SYS계정에서 소유 생략가능

SELECT SUBSTR('SQL PROJECT', 1, 3)  RESULT1
     , SUBSTR('SQL PROJECT', 5)  RESULT2
     , SUBSTR('SQL PROJECT', -7, 3) RESULT3 --m이 음수이면 뒤쪽에서부터 처리
FROM DUAL;

SELECT REPLACE('SQL Project', 'SQL', 'SSQQLL')AS 문자치환1
     , REPLACE('Java Flex Via', 'a')AS 문자치환2
     , REPLACE('SQL Project', 'Proj', 'PROJ')AS 문자치환1_2
FROM DUAL;

--1. 상위 문장에서 첫번째 ha의 위치를 출력
--2. 상위 문장에서 두번째 ha의 위치를 출력
SELECT INSTR('hello heidi', 'he')  AS RESULT1--인덱스 1부터
     , INSTR('hello heidi', 'he', 3) AS RESULT2--인덱스 3부터 출발
     , INSTR('hello heidi', 'di') RESULT3--인덱스 1부터
     , INSTR('hello heidi', 'he', 1,2) AS RESULT4--인덱스 1부터 출발, 2번째
FROM DUAL;

--mepch@test.com
--상위 문자열에서 @를 기준으로 다음과 같이 출력하기
--아이디 | 도메인
--mepch | test.com
SELECT SUBSTR('mepch@test.com',1,INSTR('mepch@test.com', '@')-1) 아이디
     , SUBSTR('mepch@test.com',INSTR('mepch@test.com', '@')+1) 도메인
FROM   DUAL;

SELECT BUYER_ID            거래처코드
     , LENGTH(BUYER_ID)    거래처코드길이
     , BUYER_NAME          거래처명
     , LENGTH(BUYER_NAME)  거래처명길이
     , LENGTHB(BUYER_NAME) 거래처명byte수
FROM   BUYER;

SELECT  ABS(-365) FROM DUAL; --절대값
SELECT SIGN(12),  SIGN(0),  SIGN(-55) FROM DUAL; --양수,음수,0 구분 각 1,-1,0 반환
SELECT  POWER(3, 2), POWER(2, 10) FROM DUAL; --제곱
SELECT  SQRT(2), SQRT(9) FROM DUAL; --루트

SELECT GREATEST(10, 20, 30) "큰값"
     , LEAST(10,20,30) "작은값"
FROM DUAL;

SELECT ROUND(MEM_MILEAGE / 12, 2) 소수2째자리살리기반올림
     , TRUNC(MEM_MILEAGE / 12, 2) 소수2째자리살리기버림
FROM   MEMBER;

--상품테이블의
--평균판매가를
--소수점 2째자리까지 반올림하여 표시하시오
SELECT AVG(PROD_SALE) AS 평균판매가
     , ROUND(AVG(PROD_SALE), 2) 결과
FROM   PROD;

MOD : 나머찌를 구하는 함수. JAVA에서 %와 같은 역할 수행
내림(FLOOR)과 올림(CEIL)
SELECT MOD(10,3) FROM DUAL;
SELECT FLOOR(1332.69), CEIL(1332.69) FROM DUAL;
SELECT FLOOR(-1332.69), CEIL(-1332.69) FROM DUAL;
SELECT FLOOR(2.69), CEIL(2.69) FROM DUAL;
SELECT FLOOR(-2.69), CEIL(-2.69) FROM DUAL;

SELECT LAST_NAME
     , JOB_ID
FROM   EMPLOYEES
WHERE  MANAGER_ID IS NULL;

SELECT LAST_NAME
     , SALARY
     , NVL(COMMISSION_PCT,0)
FROM   EMPLOYEES
WHERE  1=1
--AND NOT(COMMISSION_PCT IS NULL)
ORDER  BY 2 DESC, NVL(COMMISSION_PCT,0) DESC;

-- date + NUMBER : 숫자만큼 일수가 더해진 날짜  Return
-- date - NUMBER  : 숫자만큼 일수가 빠진 날짜  Return
-- date - date           : 두 날짜 사이의 일수 Return
-- date + 1 / 24         : 한시간을 더한 날짜  Return

--SYSDATE : 현재날짜&시간 출력
--TO_CHAR() : 문자로 형변환하는 함수일때 형식을 저장해 줄수 있음.
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS') "현재시간"
     , SYSDATE - 1  "어제 이시간"
     , SYSDATE + 1  "내일 이시간"
     , TO_CHAR(SYSDATE + 1/24, 'YYYY-MM-DD HH:MI:SS') "1시간후"
FROM   DUAL;
