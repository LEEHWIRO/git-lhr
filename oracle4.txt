--simple-case-expression
SELECT
  CASE '나' WHEN '철호' THEN '아니다'
            WHEN '너' THEN '아니다'
             WHEN '나' THEN '맞다'
             ELSE '모르겠다'
  END RESULT
FROM DUAL;
SELECT     
   CASE     WHEN '철호' = '나' THEN '아니다'
            WHEN '너'   = '나' THEN '아니다'
            WHEN '나'   = '나' THEN '맞다'
            ELSE '모르겠다'
  END RESULT
FROM DUAL;

--문제) 회원테이블(MEMBER)에서 주민등록번호(MEM_REGNO2)의
--첫번째 자리를 통해 성별을 구분해보기.
--ALIAS : 회원ID(MEM_ID), 회원명(MEM_NAME)
--,주민번호2(MEM_REGNO2), 성별
--(CASE WHEN 구문 사용)

SELECT MEM_ID 회원ID
     , MEM_NAME 회원명
     , MEM_REGNO2 주민번호2
     , CASE
    WHEN SUBSTR(MEM_REGNO2,1,1) = 1 THEN '남자'
    WHEN SUBSTR(MEM_REGNO2,1,1) = 2 THEN '여자'
    WHEN SUBSTR(MEM_REGNO2,1,1)IN('1','3') THEN'남자'
    WHEN SUBSTR(MEM_REGNO2,1,1)IN('2','4') THEN'여자'
  END "성별"
FROM MEMBER;

SELECT PROD_NAME AS "상품"
     , PROD_PRICE AS "판매가"
     , CASE
         WHEN (100000 - PROD_PRICE) >= 0 THEN '10만원미만'
         WHEN (200000 - PROD_PRICE) >= 0 THEN '10만원대'
         WHEN (300000 - PROD_PRICE) >= 0 THEN '20만원대'
         WHEN (400000 - PROD_PRICE) >= 0 THEN '30만원대'
         WHEN (500000 - PROD_PRICE) >= 0 THEN '40만원대'
         WHEN (600000 - PROD_PRICE) >= 0 THEN '50만원대'
         WHEN (700000 - PROD_PRICE) >= 0 THEN '60만원대'
         WHEN (800000 - PROD_PRICE) >= 0 THEN '70만원대'
         WHEN (900000 - PROD_PRICE) >= 0 THEN '80만원대'
         WHEN (1000000 - PROD_PRICE) >= 0 THEN '90만원대'
         ELSE '100만원이상'
        END "가격대"
FROM PROD;

--등푸른생선
DELETE FROM LPROD
WHERE LPROD_ID > 9;

--CARTESSIAN PRODUCT(ORACLE 구문)
SELECT *
FROM LPROD, PROD;

--CARTESSIAN PRODUCT(ANSI 표준)
SELECT *
FROM LPROD CROSS JOIN PROD;

--모든 행과 열이 조합됨
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S, R;

--ANSI표준
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S CROSS JOIN R;

--EQUI JOIN(내부조인)
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S, R
WHERE  R.C = S.C;

--ANSI표준(내부조인)
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S INNER JOIN R
ON(R.C = S.C);

--집계함수 5인방
/*
SUM : 그룹하여 합계
AVG : 그룹하여 평균
MAX : 그룹하여 최댓값
MIN : 그룹하여 최솟값
COUNT : 그룹하여 개수

--조인(오라클)
기티전프로덕트 : 모든 행과 열을 조합
내부조인 : 기본키 외래키를 연결고리로 하여 조인
외부조인 : 한쪽 테이블의 모든 행을 출력
셀프조인 : 하나의 테이블이 여러 테이블처럼 처리

--조인(ANSI표준)
CROSS JOIN : 모든 행과 열을 조합(==기티전프로덕트)
INNER JOIN : 기본키 외래키를 연결고리로 하여 조인(내부조인)
OUTER JOIN : 하나의 테이블이 여러 테이블처럼 처리(외부조인)
NATURAL JOIN : 연결고리를 알아서 매핑하여 조인
SELF JOIN : 하나의 테이블이 여러 테이블처럼 처리(셀프조인)
*/

--세개테이블 조인
SELECT *
FROM PROD A, CART B, MEMBER C
WHERE B.CART_PROD = A.PROD_ID
AND   B.CART_MEMBER = C.MEM_ID;
--조인(ANSI표준)
SELECT *
FROM PROD A INNER JOIN CART B ON ( B.CART_PROD = A.PROD_ID)
            INNER JOIN MEMBER C ON( B.CART_MEMBER = C.MEM_ID);

--회원테이블의 취미종류수를 COUNT집계 하시오
-- (ALIAS : 취미종류수)
SELECT COUNT(DISTINCT MEM_LIKE) 취미종류수
FROM   MEMBER;

--회원테이블의 취미별 count집계 하시오
-- (ALIAS : 취미 자료수 자료수(*))
SELECT MEM_LIKE
     , COUNT(MEM_LIKE) 자료수
     , COUNT(MEM_LIKE) "자료수(*)"
FROM   MEMBER
GROUP BY MEM_LIKE;
--집계복음 3장 16절
--집계함수 이외의 컬럼들은 GROUP BY 절에 기술해야 하느니라.
--장바구니 테이블의 회원(CART_MEMBER) 별 COUNT집계 하시오?
--ALIAS : 학생ID, 구매수(DISTINCT),구매수, 구매수(*)
SELECT CART_MEMBER 회원ID
     , COUNT(DISTINCT CART_MEMBER) 회원ID중복제거
     , COUNT(CART_MEMBER) 회원ID인원수
     , COUNT(*) 전체행의개수
FROM   CART
GROUP BY CART_MEMBER;

/*
* 거래처명(BUYER_NAME)을 알아내기 위해서는
..
1) BUYPROD 테이블의 BUY_PROD컬럼과
PROD테이블의 PROD_ID
컬럼을 통해 PROD테이블의 PROD_BUYER를
알아내고
2) PROD테이블의 PROD_BUYER컬럼과
BUYER테이블의 BUYER_ID컬럼을
통해 BUYER테이블의 BUYER_NAME을 알아냄
*/

--문제
--2005년도 월별 "모든!!"상품분류별
--매출 현황을 검색하시오
--ALIAS는 월(CART_NO사용), 상품분류(LPROD_NM),
--매출금액(PROD_SALE * CART_QTY)
SELECT SUBSTR(CART_NO,5,2) 월
     , LPROD_NM 상품분류
     , NVL(SUM(PROD_SALE * CART_QTY),0) 매출현황
FROM   CART, PROD, LPROD
WHERE  CART_PROD(+) = PROD_ID
AND    PROD_LGU(+) = LPROD_GU
--AND    CART_NO LIKE '2005%'
GROUP BY SUBSTR(CART_NO,5,2), LPROD_NM
ORDER BY SUBSTR(CART_NO,5,2);

--조인정리
카티젼프로덕트 : 모든 열과 행이 조합
내부조인 : 카티젼프로덕트 결과에서 기본키 = 외래키 인 데이터
외부조인 : 한쪽의 모든 데이터를출력(기본은 내부조인)
셀프조인 : 하나의 테이블을 마치 여러개의 테이블처럼 조인

--ANSI 표준
CROSS JOIN : 카티젼프로덕트
INNER JOIN : 내부조인
OUTER JOIN : 외부조인
SELF JOIN  : 셀프조인
NATURAL JOIN
--집계함수 5총사 / 집계복음 : 집계함수 이외의 컬럼들은 GROUP BY 절에 그대로 모두 기술함
SUM
AVG
MAX
MIN
COUNT
--집계가 완료된 후에 집계함수 자체에 조건을 줄때
HAVING
