SELECT DECODE(7
             , 10, 'A'
             , 9, 'B'
             , 8, 'C'
             , 'D')
FROM DUAL;

--p.207
--상품 분류 중  앞의 두 글자가  'P1' 이면 판매가를 10%인상하고
--'P2' 이면 판매가를 15%인상하고,  나머지는 동일 판매가로 
--검색하시오 ? 
--(DECODE 함수 사용, Alias는 상품명, 판매가, 변경판매가 )
SELECT PROD_NAME 상품명
     , PROD_SALE 판매가
     , DECODE(SUBSTR(PROD_LGU,1,2) 
            , 'P1',PROD_SALE * 1.1
            , 'P2',PROD_SALE * 1.15
            ,PROD_SALE) 변경판매가
FROM   PROD;

--대전측기사에서는 3월에 생일인(MEM_BIR) 회원을
--대상으로 마일리지를 10% 인상해주는 이벤트를
--시행하고자 한다. 생일이 3월이 아닌 회원은
--짝수인 경우만 5% 인상 처리한다.
--이를 위한 SQL을 작성하시오.
--ALIAS : 회원ID, 회원명, 마일리지, 변경마일리지
SELECT MEM_ID 회원ID
     , MEM_NAME 회원명
     , MEM_MILEAGE 마일리지
     , MEM_BIR 생일
     , DECODE(SUBSTR(MEM_BIR,5,1)
            , 3,MEM_MILEAGE * 1.1
            , DECODE(MOD(SUBSTR(MEM_BIR,5,1),2)
                   , 0,MEM_MILEAGE*1.05
                   ,MEM_MILEAGE)) 변경마일리지 
FROM   MEMBER;

--simple-case-expression
SELECT
  CASE '나' WHEN '철호' THEN '아니다'
            WHEN '너' THEN '아니다'
             WHEN '나' THEN '맞다'
             ELSE '모르겠다'
  END RESULT
FROM DUAL;
SELECT     
   CASE     WHEN '철호' = '나' THEN '아니다'
            WHEN '너'   = '나' THEN '아니다'
            WHEN '나'   = '나' THEN '맞다'
            ELSE '모르겠다'
  END RESULT
FROM DUAL;

--문제) 회원테이블(MEMBER)에서 주민등록번호(MEM_REGNO2)의
--첫번째 자리를 통해 성별을 구분해보기.
--ALIAS : 회원ID(MEM_ID), 회원명(MEM_NAME)
--,주민번호2(MEM_REGNO2), 성별
--(CASE WHEN 구문 사용)

SELECT MEM_ID 회원ID
     , MEM_NAME 회원명
     , MEM_REGNO2 주민번호2
     , CASE
    WHEN SUBSTR(MEM_REGNO2,1,1) = 1 THEN '남자'
    WHEN SUBSTR(MEM_REGNO2,1,1) = 2 THEN '여자'
    WHEN SUBSTR(MEM_REGNO2,1,1)IN('1','3') THEN'남자'
    WHEN SUBSTR(MEM_REGNO2,1,1)IN('2','4') THEN'여자'
  END "성별"
FROM MEMBER;

SELECT PROD_NAME AS "상품"
     , PROD_PRICE AS "판매가"
     , CASE
         WHEN (100000 - PROD_PRICE) >= 0 THEN '10만원미만'
         WHEN (200000 - PROD_PRICE) >= 0 THEN '10만원대'
         WHEN (300000 - PROD_PRICE) >= 0 THEN '20만원대'
         WHEN (400000 - PROD_PRICE) >= 0 THEN '30만원대'
         WHEN (500000 - PROD_PRICE) >= 0 THEN '40만원대'
         WHEN (600000 - PROD_PRICE) >= 0 THEN '50만원대'
         WHEN (700000 - PROD_PRICE) >= 0 THEN '60만원대'
         WHEN (800000 - PROD_PRICE) >= 0 THEN '70만원대'
         WHEN (900000 - PROD_PRICE) >= 0 THEN '80만원대'
         WHEN (1000000 - PROD_PRICE) >= 0 THEN '90만원대'
         ELSE '100만원이상'
        END "가격대"
FROM PROD;

--등푸른생선
DELETE FROM LPROD
WHERE LPROD_ID > 9;

--CARTESSIAN PRODUCT(ORACLE 구문)
SELECT *
FROM LPROD, PROD;

--CARTESSIAN PRODUCT(ANSI 표준)
SELECT *
FROM LPROD CROSS JOIN PROD;

--모든 행과 열이 조합됨
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S, R;

--ANSI표준
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S CROSS JOIN R;

--EQUI JOIN(내부조인)
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S, R
WHERE  R.C = S.C;

--ANSI표준(내부조인)
select R.A, R.B, R.C RC,
       S.C SC, S.D, S.E
from   S INNER JOIN R
ON(R.C = S.C);

--집계함수 5인방
/*
SUM : 그룹하여 합계
AVG : 그룹하여 평균
MAX : 그룹하여 최댓값
MIN : 그룹하여 최솟값
COUNT : 그룹하여 개수

--조인(오라클)
기티전프로덕트 : 모든 행과 열을 조합
내부조인 : 기본키 외래키를 연결고리로 하여 조인
외부조인 : 한쪽 테이블의 모든 행을 출력
셀프조인 : 하나의 테이블이 여러 테이블처럼 처리

--조인(ANSI표준)
CROSS JOIN : 모든 행과 열을 조합(==기티전프로덕트)
INNER JOIN : 기본키 외래키를 연결고리로 하여 조인(내부조인)
OUTER JOIN : 하나의 테이블이 여러 테이블처럼 처리(외부조인)
NATURAL JOIN : 연결고리를 알아서 매핑하여 조인
SELF JOIN : 하나의 테이블이 여러 테이블처럼 처리(셀프조인)
*/

--세개테이블 조인
SELECT *
FROM PROD A, CART B, MEMBER C
WHERE B.CART_PROD = A.PROD_ID
AND   B.CART_MEMBER = C.MEM_ID;
--조인(ANSI표준)
SELECT *
FROM PROD A INNER JOIN CART B ON ( B.CART_PROD = A.PROD_ID)
            INNER JOIN MEMBER C ON( B.CART_MEMBER = C.MEM_ID);

--회원테이블의 취미종류수를 COUNT집계 하시오
-- (ALIAS : 취미종류수)
SELECT COUNT(DISTINCT MEM_LIKE) 취미종류수
FROM   MEMBER;

--회원테이블의 취미별 count집계 하시오
-- (ALIAS : 취미 자료수 자료수(*))
SELECT MEM_LIKE
     , COUNT(MEM_LIKE) 자료수
     , COUNT(MEM_LIKE) "자료수(*)"
FROM   MEMBER
GROUP BY MEM_LIKE;
--집계복음 3장 16절
--집계함수 이외의 컬럼들은 GROUP BY 절에 기술해야 하느니라.
--장바구니 테이블의 회원(CART_MEMBER) 별 COUNT집계 하시오?
--ALIAS : 학생ID, 구매수(DISTINCT),구매수, 구매수(*)
SELECT CART_MEMBER 회원ID
     , COUNT(DISTINCT CART_MEMBER) 회원ID중복제거
     , COUNT(CART_MEMBER) 회원ID인원수
     , COUNT(*) 전체행의개수
FROM   CART
GROUP BY CART_MEMBER;

/*
* 거래처명(BUYER_NAME)을 알아내기 위해서는
..
1) BUYPROD 테이블의 BUY_PROD컬럼과
PROD테이블의 PROD_ID
컬럼을 통해 PROD테이블의 PROD_BUYER를
알아내고
2) PROD테이블의 PROD_BUYER컬럼과
BUYER테이블의 BUYER_ID컬럼을
통해 BUYER테이블의 BUYER_NAME을 알아냄
*/

--문제
--2005년도 월별 "모든!!"상품분류별
--매출 현황을 검색하시오
--ALIAS는 월(CART_NO사용), 상품분류(LPROD_NM),
--매출금액(PROD_SALE * CART_QTY)
SELECT SUBSTR(CART_NO,5,2) 월
     , LPROD_NM 상품분류
     , NVL(SUM(PROD_SALE * CART_QTY),0) 매출현황
FROM   CART, PROD, LPROD
WHERE  CART_PROD(+) = PROD_ID
AND    PROD_LGU(+) = LPROD_GU
--AND    CART_NO LIKE '2005%'
GROUP BY SUBSTR(CART_NO,5,2), LPROD_NM
ORDER BY SUBSTR(CART_NO,5,2);

--조인정리
카티젼프로덕트 : 모든 열과 행이 조합
내부조인 : 카티젼프로덕트 결과에서 기본키 = 외래키 인 데이터
외부조인 : 한쪽의 모든 데이터를출력(기본은 내부조인)
셀프조인 : 하나의 테이블을 마치 여러개의 테이블처럼 조인

--ANSI 표준
CROSS JOIN : 카티젼프로덕트
INNER JOIN : 내부조인
OUTER JOIN : 외부조인
SELF JOIN  : 셀프조인
NATURAL JOIN
--집계함수 5총사 / 집계복음 : 집계함수 이외의 컬럼들은 GROUP BY 절에 그대로 모두 기술함
SUM
AVG
MAX
MIN
COUNT
--집계가 완료된 후에 집계함수 자체에 조건을 줄때
HAVING

--전체상품의 2005년 1월 입고수량을 검색 조회
SELECT A.PROD_ID 상품코드
     , A.PROD_NAME 상품명
     , SUM(B.BUY_QTY) 입고수량
FROM   PROD A, BUYPROD B
WHERE  A.PROD_ID = B.BUY_PROD(+)
--AND    BUY_DATE LIKE '05/01%'
GROUP BY A.PROD_ID, A.PROD_NAME
ORDER BY A.PROD_ID;

SELECT A.PROD_ID 상품코드
     , A.PROD_NAME 상품명
     , NVL(SUM(B.BUY_QTY),0) 입고수량
FROM   PROD A
LEFT OUTER JOIN BUYPROD B
  ON(A.PROD_ID = B.BUY_PROD AND BUY_DATE LIKE '05/01%')
GROUP BY A.PROD_ID, A.PROD_NAME
ORDER BY A.PROD_ID;

--전체 회원의 2005년도 4월의 구매현황 조회
--    ( 회원ID, 성명, 구매수량의 합 )
SELECT MEM_ID
     , MEM_NAME
     , SUM(CART_QTY)
FROM   MEMBER, CART
WHERE MEM_ID = CART_MEMBER
AND CART_NO LIKE '200504%'
GROUP BY MEM_ID ,MEM_NAME
ORDER BY MEM_ID ,MEM_NAME;

SELECT A.MEM_ID 회원ID
     , A.MEM_NAME 성명
     , NVL(SUM(B.CART_QTY),0) 구매수량의합
FROM   MEMBER A
LEFT OUTER JOIN CART B
ON (A.MEM_ID = B.CART_MEMBER AND B.CART_NO LIKE '200504%')
GROUP BY A.MEM_ID ,A.MEM_NAME
ORDER BY A.MEM_ID ,A.MEM_NAME;
