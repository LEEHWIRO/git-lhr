I. PL/SQL 
1. PL/SQL
Anonymous block : 단순 스크립트에서 실행되는 블록 서버에 저장되지 않는다.
Stored Procedure : 자주 실행되거나, 복잡한 비지니스 로직을 미리 작성하여 서버에 저장하여 사용한다.
User Function : Procedure 와 유사하며, 실행결과를 반환한다.
Package : 여러 Procedure, Function 및 변수등을 하나로 묶는다.
Trigger : 테이블이나 뷰에 INSERT, UPDATE, DELETE 등이 수행 전 또는 수행 후 자동 실행되는 Procedure
2. 절차형 SQL 문법
(1). 블록
(2). 문장

3. 절차형 SQL 실행원리
DECLARE
 - Declation Section(옵션)
  : 변수, 상수, CURSOR 와 USER_DEFINE Exception 등 선언
BEGIN
 - Excutable Section(필수)
  : 처리할 명령문들을 절차적으로 기술SQL문, 반복문, 조건문, BEGIN으로 시작 END로 끝남
EXCEPTION
 - Exception Section(옵션)
  : 오류처리에 관한 명령문을 기술
END

/
SET SERVEROUTPUT ON; -- 로그인
/
DECLARE
  V_I NUMBER(9,2) := 123456.78;
  V_STR VARCHAR2(20) := '홍길동';
  C_PI CONSTANT NUMBER(8,6) := 3.141592;
  V_FLAG BOOLEAN NOT NULL := TRUE;
  V_DATE VARCHAR2(10) := TO_CHAR(SYSDATE, 'YYYY-MM-DD');
BEGIN
  DBMS_OUTPUT.PUT_LINE('V_I : ' ||V_I);
  DBMS_OUTPUT.PUT_LINE('V_STR : ' ||V_STR);
  DBMS_OUTPUT.PUT_LINE('C_PI : ' ||C_PI);
  DBMS_OUTPUT.PUT_LINE('V_DATE : ' ||V_DATE);
 --SYSTEM.OUT.PRINTLN('V_I : '||V_I);
END;
/

4. 매개변수
 (1). 변수의 종류
      SCLAR 변수 : 데이터 하나만을 저장하는 일반적인 변수
      REFERENCES 변수 : 해당 테이블의 row나 column의 타입과 크기를 참조하는 변수
      COMPOSITE 변수 : PL/SQL에서 사용하는 배열 변수 RECODE TYPE   TABLE TYPE
      BIND 변수 : 파라미터로 넘겨지는 IN, INOUT에서 사용되는 변수 리턴되는 값을 전달받기 위해 선언되는 변수
 (2). SCLAR 변수에 사용되는 데이터형
 CHAR[(N)] : 고정길이문자 / BINARY_INTEGER : 정수 / PLS_INTEGER : 정수(속도 빠름) / 
 NUMBER[(P, S)] : 고정 및 부동 소숫점 수 / VARCHAR2(N) : 가변길이문자열 / DATE : 날짜 /
 BOOLEAN : 논리 / LONG, LONG RAW :Deprecated / 
 (3). REFERENCES 변수에 사용되는 데이터형
 테이블명.컬럼명%TYPE : 해당 테이블의 해당 컬럼의 타입과 동일하게 설정
 테이블명%ROWTYPE : 해당 테이블의 모든 컬럼과 동일하게 지정

5. 분기문
 (1). IF문
 -조건이 TRUE이면 이하 문장을 실행하고, FALSE이면 관련된 문장을 통과한다.
 -ELSIF절은 여러 개가 가능하나, ELSE절은 한 개만 가능하다.
예재1.
DECLARE
  V_NUM NUMBER := 37;
BEGIN
  --DBMS_OUTPUT.ENABLE
  IF MOD(V_NUM,2) = 0 THEN
    DBMS_OUTPUT.PUT_LINE(V_NUM || '는 짝수');
  ELSE
    DBMS_OUTPUT.PUT_LINE(V_NUM || '는 홀수');
  END IF;
END;
/
예재2. 조건에 따른 다중 ELSIF
DECLARE
  V_NUM NUMBER := 77;
BEGIN
  IF V_NUM > 90 THEN
    DBMS_OUTPUT.PUT_LINE('수');
  ELSIF V_NUM > 80 THEN
    DBMS_OUTPUT.PUT_LINE('우');
  ELSIF V_NUM > 70 THEN
    DBMS_OUTPUT.PUT_LINE('미');
  ELSE
    DBMS_OUTPUT.PUT_LINE('분발합시다');
  END IF;
END;
/
예재3. SELECT INTO 로 변수에 값을 할당
DECLARE
  V_AVG_SALE PROD.PROD_SALE%TYPE; --NUMBER(10) --(REFRENCE 변수)
  V_SALE NUMBER := 500000;        --(SCLAR 변수)
BEGIN
  SELECT AVG(PROD_SALE) INTO V_AVG_SALE FROM PROD;
  IF V_SALE < V_AVG_SALE THEN
    DBMS_OUTPUT.PUT_LINE('평균 단가가 500000 초과입니다.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('평균 단가가 500000 이하입니다.');
  END IF;
END;
/
--회원테이블에서 아이디가 'e001' 인 회원의  
--마일리지가 5000을 넘으면 'VIP 회원' 
--그렇지 않다면 '일반회원'으로 
--출력하시오. (회원이름, 마일리지 포함) 
DECLARE
    V_MILEAGE NUMBER := 0;
--  V_NAME    VARCHAR2(20); --SCLAR변수
    V_NAME    MEMBER.MEM_NAME%TYPE; --REFERENCE 변수
BEGIN
  SELECT MEM_MILEAGE, MEM_NAME INTO V_MILEAGE, V_NAME --7150, 이혜나
  FROM   MEMBER
  WHERE  MEM_ID = 'e001';
  
  IF V_MILEAGE > 5000 THEN
      DBMS_OUTPUT.PUT_LINE('VIP회원');
  ELSE
      DBMS_OUTPUT.PUT_LINE('일반회원');
  END IF;
  DBMS_OUTPUT.PUT('V_MILEAGE : ' || V_MILEAGE); -- LINE : 줄넘김
  DBMS_OUTPUT.PUT_LINE('V_NAME : ' || V_NAME);
END;
/
 (2). CASE 문
DECLARE
  V_NUM NUMBER := 77;
BEGIN
  CASE WHEN V_NUM > 90 THEN
    DBMS_OUTPUT.PUT_LINE('수');
  WHEN V_NUM > 80 THEN
    DBMS_OUTPUT.PUT_LINE('우');
  WHEN V_NUM > 70 THEN
    DBMS_OUTPUT.PUT_LINE('미');
  ELSE
    DBMS_OUTPUT.PUT_LINE('분발합시다');
  END CASE;
END;
/
--상품분류가 화장품인 상품의 평균판매가를
--구한 후 평균판매가가 3,000원 미만이면 
--싸다, 3,000원 이상 ~ 6,000원 미만이면 보통,
--6,000원 이상 ~ 9,000원 미만이면 비싸다,
--9,000원 이상이면 너무비싸다를 출력하기
--단, CASE 문 사용하여 처리하기
--출력형식 : 화장품의 평균판매가는 5000원이고 보통이다.
DECLARE
    V_SALE NUMBER;-- 실수
    V_STR  VARCHAR2(20);
BEGIN
    SELECT ROUND(AVG(NVL(PROD_SALE,0)),2) INTO V_SALE --54233.33
    FROM   PROD
    WHERE  PROD_LGU = (
             SELECT LPROD_GU FROM LPROD
             WHERE  LPROD_NM = '화장품'
        );
        
  DBMS_OUTPUT.PUT_LINE('V_SALE : ' || V_SALE);
        
  CASE WHEN V_SALE < 3000 THEN 
         V_STR := ('싸다');
       WHEN V_SALE >= 3000 AND V_SALE < 6000 THEN
         V_STR := ('보통');
       WHEN V_SALE >= 6000 AND V_SALE < 9000 THEN 
         V_STR := ('비싸다');
       ELSE
         V_STR := ('너무비싸다');
    END CASE;
    
    DBMS_OUTPUT.PUT_LINE('화장품의 평균판매가는 ' || V_SALE ||
             '원이고 ' ||V_STR);
END;
/
--가파치 업체의 지역을 검색하여
--다음과 같이 출력하기
--대구 : 경북 
--부산 : 경남
--대전 : 충청
--서울, 인천 : 수도권
--기타 : 기타
--단, CASE문 사용하기
DECLARE
  V_ADD1 VARCHAR2(30);
  V_STR  VARCHAR2(30);
BEGIN
    SELECT SUBSTR(BUYER_ADD1,1,2) INTO V_ADD1 --대구
    FROM   BUYER
    WHERE  BUYER_NAME = '가파치';
  CASE WHEN V_ADD1 = ('대구') THEN
    V_STR :=('경북');
     WHEN V_ADD1 = ('부산') THEN
    V_STR :=('경남');
     WHEN V_ADD1 = ('대전') THEN
    V_STR :=('충청');
     WHEN V_ADD1 = ('서울')AND V_ADD1 = ('인천') THEN
    V_STR :=('수도권');
    ELSE
    V_STR :=('기타');
     
END CASE;
DBMS_OUTPUT.PUT_LINE('가파치의 ' || V_ADD1 ||
             ' : ' ||V_STR);
END;
/
6.반복문
 (1). WHILE문
 반복될 떄마다 조건을 확인하고 조건이 TRUE가 되어야 LOOP실행
  - 조건이 만족할 때까지 반복 처리
  - EXIT문은 WHILE LOOP를 벗어나게한다.
  - CONTINUE문은 11g부터 제공한다.
--1부터 10까지 더하기
DECLARE 
   V_SUM NUMBER := 0;
   V_VAR NUMBER := 1;
BEGIN
   WHILE V_VAR <= 10 LOOP
      V_SUM := V_SUM + V_VAR;
      V_VAR := V_VAR + 1;
   END LOOP;
   DBMS_OUTPUT.PUT_LINE('1부터 10까지의 합 ='||V_SUM);
END;
/
--구구단
DECLARE
   V_DAN NUMBER := 2;
   V_I NUMBER := 1;
BEGIN
   WHILE V_DAN < 10 LOOP
      DBMS_OUTPUT.PUT_LINE(V_DAN||'단');
      WHILE V_I <10 LOOP
         DBMS_OUTPUT.PUT(V_DAN||'*'||V_I||'='||V_DAN * V_I||' ');
         V_I := V_I + 1;
      END LOOP;
      DBMS_OUTPUT.PUT_LINE('');
      V_I := 1;
      V_DAN := V_DAN + 1;
   END LOOP;
END;
/
DECLARE
    V_ADD  NUMBER(5) := 1000;
    V_CODE CHAR(4) := '';
    V_ID   NUMBER(5) := 0;
BEGIN 
    SELECT MAX(LPROD_ID) INTO V_ID
    FROM   LPROD;
    WHILE  V_ADD <= 1005 LOOP
        V_ADD := V_ADD + 1;
        V_ID  := V_ID  + 1;
        V_CODE := 'TT' || SUBSTR(TO_CHAR(V_ADD), -2);
        INSERT INTO LPROD(LPROD_ID, LPROD_GU, LPROD_NM)
        VALUES(V_ID, V_CODE, 'LOOP TEST');
        IF SQL%FOUND THEN
            DBMS_OUTPUT.PUT_LINE('신규코드'||V_CODE ||'가 추가되었음');
        END IF;
    END LOOP;
END;
/
 (4) FOR 문
  - index는 1씩 증가하는 자동선언 정수형 변수(최소, 최대값)
  - REVERSE 가 사용될 경우 1씩 감소
  - IN 다음에 SELECT 문, CURSOR 문이 올 수 있다.
  - SELECT, CURSOR 를 사용한 경우 index는 레코드타입 변수
  
FOR index IN [REVERSE] 최소값 .. 최대값 LOOP
    처리문장들;
   END LOOP;
   
--1씩 증가
BEGIN
    --i : 자동선언 정수형 변수
    FOR i IN 1 .. 10 LOOP -- 시작 .. 종료
        DBMS_OUTPUT.PUT_LINE('i=' || i);
    END LOOP;
END;
/
--1씩 감소
BEGIN
    --i : 자동선언 정수형 변수
    FOR i IN REVERSE 1 .. 10 LOOP -- 시작 .. 종료
        DBMS_OUTPUT.PUT_LINE('i=' || i);
    END LOOP;
END;
/
--FOR문을 사용하여 구구단 출력하기
BEGIN 
    --i : 자동선언 정수형 변수
    FOR i IN 2..9 LOOP
      DBMS_OUTPUT.PUT_LINE(i||'단');
      FOR j IN 1..9 LOOP
      DBMS_OUTPUT.PUT_LINE(i || '*' || j || '=' || i*j);
      END LOOP;
    END LOOP;
END;
/
--FOR 문제
--변수 및 FOR문을 활용하여 LPROD테이블의
--LPROD_ID, LPROD_GU,LPROD_NM을
--출력하시오. 최소값과 최대값은 변수로 처리하시오
DECLARE
  V_ID  NUMBER;
  V_GU  VARCHAR2(10);
  V_NM  VARCHAR2(30);
  V_MIN NUMBER; --:= 1;
  V_MAX NUMBER; --:= 9;
BEGIN 
    --방법 1
--  FOR i IN 1..9 LOOP
--  SELECT LPROD_ID, LPROD_GU, LPROD_NM 
--         INTO V_ID, V_GU, V_NM
--  FROM   LPROD
--  WHERE  LPROD_ID = i;
    --방법 2
  SELECT MIN(LPROD_ID), MAX(LPROD_ID) INTO V_MIN, V_MAX
  FROM   LPROD;
  FOR i IN V_MIN..V_MAX LOOP
      SELECT LPROD_ID, LPROD_GU, LPROD_NM 
             INTO V_ID, V_GU, V_NM
      FROM   LPROD
      WHERE  LPROD_ID = i;
  DBMS_OUTPUT.PUT_LINE(V_ID||' '||V_GU||' '||V_NM);
  END LOOP;
END;
/

II. Exception
1. Exception
 (1). Exception 구문 
   EXCEPTION 
        WHEN exception1 [OR exception2 …] THEN 
                     statement1;
                     statement2;…
         [ WHEN exception2 [OR exception4…]  THEN
                     statement1;
                     statement2;…  ] 
         [ WHEN OTHERS THEN
                     statement1;
                     statement2;…  ] 
exception n : 미리 정의된 예외 또는 선언부에 선언된 예외 이름
statement n : PL/SQL 또는 SQL 구문
WHEN OTHERS : 명시적으로 선언되지 않은 모든 예외를 처리
 (2). EXCEPTION 처리
NO_DATA_FOUND : 선택된 행이 없는 경우 (SELECT.. INTO)
TOO_MANY_ROWS : 여러 행이 리턴 되는 경우 (SELECT.. INTO)
DUP_VAL_ON_INDEX : UNIQUE인덱스가 걸린 컬럼에 중복 데이터를 입력할 때
VALUE_ERROR : 값을 할당하거나 변환할 때 오류가 나는 경우
INVALID_NUMBER : 숫자로 변환이 되지 않는 경우(문자형 데이터)
NOT_LOGGED_ON : DB에 접속하지 않은 채 실행하는 경우
LOGIN_DENIED : 잘못된 사용자나 비밀번호로 로그인을 시도할 때
ZERO_DIVIDE : 0으로 나누려고 할 때
INVALID_CURSOR : 허용되지 않은(열리지 않은) 커서에 접근하는 경우

예제 1.
DECLARE
    V_NM VARCHAR2(30);
BEGIN
    SELECT LPROD_NM + 0 INTO V_NM
    FROM   LPROD
    WHERE  LPROD_GU = 'P201';
    
    DBMS_OUTPUT.PUT_LINE('분류명 : ' || V_NM);
    
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('해당 정보가 없습니다.' || SQLCODE ||' '|| SQLERRM);
        WHEN TOO_MANY_ROWS THEN
            DBMS_OUTPUT.PUT_LINE('다중행 오류입니다');
        WHEN OTHERS THEN  --아몰랑
            DBMS_OUTPUT.PUT_LINE('기타오류' || SQLCODE ||' '|| SQLERRM);
END;
/
--정의되지 않은 예외인 경우
DECLARE 
    --예외처리형의 EXP1변수를 선언
    EXP1 EXCEPTION;
    --PRAGMA : 컴파일때만 실행 BUT, 실행시에는 실행안됨.
    --EXCEPTION_INIT : 예외처리형 EXP1변수와 오류코드번호를 매핑
    PRAGMA EXCEPTION_INIT(EXP1, -2292);
BEGIN
    DELETE FROM LPROD
    WHERE  LPROD_GU = 'P101';
     
    EXCEPTION
        WHEN EXP1 THEN
            --SQLERRM : SQL ERROR MESSAGE
            DBMS_OUTPUT.PUT_LINE('삭제불가 : ' || SQLERRM);
END;
/
--정의되지 않은 예외 문제
--MEMBER 테이블의 a001회원의 정보를 삭제
--MEMBER 테이블의 MEM_ID를 참조하고 있는
--CART 테이블의 CART_MEMBER(FK)로 인해
--MEMBER 테이블 데이턱 삭제되지 않는데
--예외로 처리하기
DECLARE
    EXP EXCEPTION;
    PRAGMA EXCEPTION_INIT(EXP, -2292);
    --ORA-02292: integrity constraint (PC16.FR_CART_MEMBER) violated - child record found
BEGIN
    DELETE FROM MEMBER
    WHERE  MEM_ID = 'a001';
    
    EXCEPTION
        WHEN EXP THEN
            DBMS_OUTPUT.PUT_LINE('삭제불가 : ' || SQLERRM); --자식 레코드 발견
END;
/
ACCEPT P_LGU PROMPT '등록하려는 분류코드 입력:'
DECLARE
    EXP_LPROD_GU EXCEPTION;
    V_LGU VARCHAR2(10) := UPPER('&P_LGU');
BEGIN
    IF V_LGU IN('P101','P102','P201','P202') THEN
        RAISE EXP_LPROD_GU;
    END IF;
    DBMS_OUTPUT.PUT_LINE(V_LGU||'는 등록가능');
EXCEPTION
    WHEN EXP_LPROD_GU THEN
        DBMS_OUTPUT.PUT_LINE(V_LGU||'는 이미 등록된 코드 입니다.');
END;
/
--사용자 정의 예외
--MEMBER 테이블에 회원ID b001을 추가하려고
--할 때 사용자 정의 예외를 발생하기
--회원ID 체크는 a001, b001, c001 로하기
ACCEPT M_ID PROMPT '등록하려는 분류코드 입력:'
DECLARE
     EXP_M_ID EXCEPTION;
     V_ID VARCHAR2(10) := LOWER('&M_ID');
BEGIN
    IF V_ID IN('a001','b001','c001') THEN
        RAISE EXP_M_ID;
    END IF;
    DBMS_OUTPUT.PUT_LINE(V_ID||'는 등록가능');
EXCEPTION
    WHEN EXP_M_ID THEN
        DBMS_OUTPUT.PUT_LINE(V_ID||'는 이미 등록된 코드 입니다.');
END;
/
--회원의 마일리지 현황을 출력하기
--단, 직업이 주부인 회원만 출력
--ALIAS : MEM_NAME, MEM_MILEAGE
--정렬 : MEM_NAME 오름차순
DECLARE
    V_NAME VARCHAR2(30);
    V_MILEAGE NUMBER;
    --커서를 선언
    CURSOR MEM_CUR IS 
        SELECT MEM_NAME, MEM_MILEAGE
        FROM   MEMBER
        WHERE  MEM_JOB = '주부'
        ORDER BY MEM_NAME ASC;
BEGIN
    --메모리 할당 및 정보를 저장
--    OPEN MEM_CUR;
--    --방법1.
--    LOOP
--        FETCH MEM_CUR INTO V_NAME, V_MILEAGE;  
--        EXIT WHEN MEM_CUR%NOTFOUND;
--        DBMS_OUTPUT.PUT_LINE(V_NAME || ', ' || V_MILEAGE);
--    END LOOP;
--    CLOSE MEM_CUR;
      --사용중인 메모리를 반환
      
    --방법2.
    FOR MEM_REC IN MEM_CUR LOOP
        DBMS_OUTPUT.PUT_LINE(MEM_REC.MEM_NAME ||
                     ', ' || MEM_REC.MEM_MILEAGE);
    END LOOP;   
END;
/ 
--상품코드를 매개변수로 하여 재고수량 ADD
CREATE OR REPLACE PROCEDURE USP_GAEDDONGI 
IS
BEGIN
  UPDATE PROD
  SET    PROD_TOTALSTOCK = PROD_TOTALSTOCK + 10
  WHERE  PROD_ID = 'P101000001';
  DBMS_OUTPUT.PUT_LINE('업데이트 완료');
  
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('예외 발생 : ' || SQLERRM);
      ROLLBACK;
END;
/
EXEC USP_GAEDDONGI;
/
SELECT PROD_TOTALSTOCK
FROM   PROD
WHERE  PROD_ID = 'P101000001';
/
--프로시저 연습문제1
CREATE TABLE PROCTEST(
  PROC_SEQ NUMBER,
  PROC_CONTENT VARCHAR2(30),
  CONSTRAINT PK_PROCTEST PRIMARY KEY(PROC_SEQ)
  );
--SEQPROC1.NEXTVAL : 1증가
--SEQPROC1.CURRVAL : 현재값
CREATE SEQUENCE SEQPROC1
START WITH 1
INCREMENT BY 1;
/

--1-1) 프로시저 PROC_TEST1을 생성
--실행하면 PROTEST 테이블에 
--1, '개똥이' 데이터가 추가되도록 처리
CREATE OR REPLACE PROCEDURE PROC_TEST1
IS
BEGIN
    INSERT INTO PROCTEST(PROC_SEQ, PROC_CONTENT)
    VALUES(SEQPROC1.NEXTVAL, '개똥이');
END;
/
EXEC PROC_TEST1;
/
SELECT * FROM PROCTEST;
/
--1-2) 프로시저 PROC_TEST2을 생성
--실행하면 PROCTEST 테이블의 마지막 데이터를 삭제
--삭제할 데이터가 없을 경우 "삭제할 데이터가 없습니다"라는 에러처리
--정의된/정의 되지 않은 EXCEPTION
--사용자 정의 EXCEPTION
CREATE OR REPLACE PROCEDURE PROC_TEST2
IS
    EXP1 EXCEPTION;
    CNT NUMBER;
BEGIN
    --마지막 번호를 조건으로 해서 DELETE처리
    DELETE FROM PROCTEST A WHERE A.PROC_SEQ = (SELECT MAX(B.PROC_SEQ) FROM PROCTEST B);
    --COUNT(*)를 해서 CNT변수에 INTO함
    SELECT COUNT(*) INTO CNT FROM PROCTEST;
    DBMS_OUTPUT.PUT_LINE('남은 건수 : ' || CNT);
    --IF문을 사용하여 CNT < 1인경우 RAISE EXP1 처리
    IF CNT < 1 THEN RAISE EXP1;
    END IF;
    EXCEPTION
        WHEN EXP1 THEN
            DBMS_OUTPUT.PUT_LINE('삭제할 데이터가 없습니다.');
END;
/
EXEC PROC_TEST2;
/
--USER DEFINED FUNCTION 연습
--회원 아이디를 받으면 해당 이름을 리턴하는 함수 만들자
--다음과 같이 출력해보기
--ALIAS : 회원ID, 회원명, 장바구니번호
--CART테이블만 이용해서 처리해보기

select CART_MEMBER 회원ID
     , FN_LHR(CART_MEMBER) 회원명
     , CART_NO     장바구니번호
from CART;
/
CREATE OR REPLACE FUNCTION FN_LHR(P_ID IN VARCHAR2)
RETURN VARCHAR2
IS 
    --SCALAR변수
    V_NAME VARCHAR2(60);
BEGIN
    --PL/SQL에서 SELECT구문이 사용된다면 꼭 INTO 구문을 사용해야함.
    SELECT MEM_NAME INTO V_NAME 
    FROM MEMBER 
    WHERE MEM_ID = P_ID;
    RETURN V_NAME;
END;
/
SELECT FN_LHR('t001') FROM DUAL;
/
SELECT BUY_PROD 상품코드
     , FN_JYJ(BUY_PROD) 상품명
     , BUY_QTY 입고수량
FROM   BUYPROD;
/
CREATE OR REPLACE FUNCTION FN_JYJ(P_ID IN VARCHAR2)
RETURN VARCHAR2
IS 
    --SCALAR변수
    V_NAME VARCHAR2(60);
BEGIN
    --PL/SQL에서 SELECT구문이 사용된다면 꼭 INTO 구문을 사용해야함.
    SELECT PROD_NAME INTO V_NAME 
    FROM PROD 
    WHERE PROD_ID = P_ID;
    RETURN V_NAME;
END;
/
CREATE OR REPLACE FUNCTION FN_PRODAVGQTY
        (P_YEAR    IN NUMBER DEFAULT(EXTRACT(YEAR FROM SYSDATE)),
         P_PROD_ID IN VARCHAR2)
    RETURN NUMBER
IS
    R_QTY NUMBER;
BEGIN 
    SELECT ROUND(AVG(NVL(CART_QTY,0)),2) INTO R_QTY
    FROM   CART
    WHERE  CART_NO LIKE P_YEAR || '%'
    AND    CART_PROD = P_PROD_ID;
    
    RETURN R_QTY;
    
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('오류 발생 : ' || SQLERRM);
END;
/
VAR QTY NUMBER
EXEC :QTY := FN_PRODAVGQTY(2005,'P101000001')
PRINT QTY;
/
SELECT PROD_ID 상품코드
     , PROD_NAME 상품명
     , FN_PRODAVGQTY(2005,PROD_ID) "2005년평균판매수량"
FROM   PROD;
/

