[Oracle Database 접속 방법]
1. RUN SQL command Line
conn sys /as sysdba
Enter password: java
Connected.
SQL> SELECT * FROM ALL_USERS; : 계정조회

2. cmd(명령프롬프트)
SQLPLUS SYS(계정)/JAVA(비번)@LOCALHOST:1521(내선번호) AS SYSDBA
SQLPLUS SYS(계정)/JAVA(비번)@127.0.0.1:1521 AS SYSDBA
SQLPLUS SYS(계정)/JAVA(비번)@IPV4주소:1521 AS SYSDBA
SQLPLUS (계정)/(비번)@IPV4주소:1521-관리자가 권한부여를 해줘야 접속가능
SQLPLUS (계정)/(비번)@LOCALHOST:1521

--데이터베이스 계정 생성
CREATE USER JOE(계정) IDENTIFIED BY BLACK(비번);

--시스템 권한 부여
GRANT {SYSTEM_PRIV | ROLE | ALL PROVILEGES}, ... 
TO {USER | ROLE | PUBLIC}, ...
[IDENTIFIED BY password]
[WITH ADMIN OPTION]

--객체권한부여
GRANT CONNECT, RESOURCE TO (계정);

GRANT {OBJECT_PRIV|ALL [PRIVILEGES]} [(COLUMN, ...) , ...
ON {DIRECTORY DIRECTORY_NAME | JAVA {SOURCE | RESOURCE} OBJECT}
TO {USER | ROLE | PUBLIC}, ...
[WITH ADMIN OPRION]
[WITH HIERARCHY OPTION] ;

--데이터베이스 계정 삭제 
DROP USER (계정) CASCADE;(계정에 테이블이 잇을시)

[테이블스페이스생성] 1. 테이블 생성 2. 사용자에게 테이블 제공
1. create tablespace gangnam
2  datafile 'c:\oraclexe\app\oracle\oradata\XE\gangnam.dbf' sizec200M;
     
2. create user (계정) identified by java
2  default tablespace gangnam
3  quota unlimited on gangnam; -> 이 사용자는 gangnam이라는 테이블스페이스 공간 200M를 사용할 수 있다.(회사에서 차장급만)

TABLE 생성(CREATE)

CREATE TABLE <테이블명>
(필드명1 TYPE [NOT NULL | NULL]
 필드명2 TYPE [NOT NULL | NULL]
                    .
                    .
                    .
CONSTRAINT 기본키명 PRIMARY KEY (필드명1, [,필드명2])
CONSTRAINT 외부키명 FOREIGN KEY (필드명2) REFERENCE 외부테이블명(외부필드명)
);

TABLE 수정(ALTER)

ALTER TABLE <테이블명>
ADD(CONSTRAINT 기본키명 PRIMARY KEY (필드명1, 필드명2),
    CONSTRAINT 외부키명 FOREIGN KEY (필드명2) REFERENCE 외부테이블명(외부필드명)
);

뷰의 구문 및 설명
CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW VIEW_NAME
[COLUMNNAME_LIST ...]
AS SELECT-STATEMENT
[WITH CHECK OPTION [CONSTRAINT constraint ] ]
[WITH READ ONLY]

TABLE 생성 및 수정 예

1.테이블 생성
 1) 상품분류 정보 테이블 생성
CREATE TABLE LPROD
( LPROD_ID NUMBER(5) NOT NULL   --순번
, LPROD_GU CHAR(4) NOT NULL     --상품분류코드
, LPROD_NM VARCHAR2(40) NOT NULL--상품분류명
, CONSTRAINT PK_LPROD PRIMARY KEY (LPROD_GU)
);
 2)거래처정보테이블 생성
CREATE TABLE BUYER
( BUYER_ID CHAR(6) NOT NULL
, BUYER_NAME VARCHAR2(40) NOT NULL
, BUYER_LGU CHAR(4) NOT NULL
, BUYER_BANK VARCHAR2(60) 
, BUYER_BANKNO VARCHAR2(60)
, BUYER_BANKNAME VARCHAR2(15)
, BUYER_ZIP CHAR(7)
, BUYER_ADD1 VARCHAR2(100)
, BUYER_ADD2 VARCHAR2(70)
, BUYER_COMTEL VARCHAR2(14) NOT NULL
, BUYER_FAX VARCHAR2(20) NOT NULL
);

2.테이블 수정
ALTER TABLE BUYER ADD
( BUYER_MAIL VARCHAR2(60) NOT NULL
, BUYER_CHARGER VARCHAR2(20)
, BUYER_TELEXT VARCHAR2(2)
);

ALTER TABLE BUYER
MODIFY ( BUYER_NAME VARCHAR2(60));

ALTER TABLE BUYER
ADD
( CONSTRAINT PK_BUYER PRIMARY KEY (BUYER_ID)
, CONSTRAINT FK_BUYER_LPROD FOREIGN KEY (BUYER_LGU
  REFERENCE LPROD(LPROD_GU)
);

ALTER TABLE BUYER
ADD CONSTRAINT CHECK_PHONE CHECK
( REGEXP_LIKE(BUYER_TELEXT, '[0-9][0-9]'));

CREATE INDEX IDX_BUYER ON BUYER (BUYER_NAME, BUYER_ID);

DROP INDEX BUYER_INX1;

SEQUENCE 

1.SEQUENCE 사용 및 수정 및 삭제

Sequence 구문
CREATE SEQUENCE sequence_name
[ START WITH  n ]
[ INCREMENT BY  n ]
[ MAXVALUE n | NOMAXVALUE ]
[ MINVALUE  n | NOMINVALUE ]
[ CYCLE | NOCYCLE ]
[ CACHE n | NOCACHE ]
[ ORDER | NOORDER ]

CREATE SEQUENCE LPROD_SEQ START WITH 10;

INSERT INTO LPROD (LPROD_ID, LPROD_GU, LPROD_NM) 
            VALUES (LPROD_SQL.NEXTVAL, 'P501', '농산물');
            
CREATE TABLE LPROD_TMP AS
SELECT LPROD_SQL.NEXTVAL, LPROD_GU, LPROD_NM 
FROM LPROD;

1. INSERT
INSERT INTO 테이블명(필드명1, 필드명2, ...)
            VALUES (값1, 값2, ...);

INSERT INTO LPROD(LPROD_ID, LPROD_GU, LPROD_NM)
            VALUES (1, 'P101', '컴퓨터제품');

INSERT 예제
 CREATE TABLE  REMAIN
(REMAIN_YEAR CHAR(04) NOT NULL,      -- 해당 년도   
 REMAIN_PROD VARCHAR2(10) NOT NULL,  -- 상품 코드   
 REMAIN_J_00 NUMBER(5),              -- 전년 재고   
 REMAIN_I NUMBER(5),                 -- 입고
 REMAIN_O NUMBER(5),                 -- 출고
 REMAIN_J_99 NUMBER(5),              -- 현재고  
 REMAIN_DATE DATE,                   -- 처리일자
CONSTRAINT PK_REMAIN PRIMARY KEY(REMAIN_YEAR, REMAIN_PROD),
CONSTRAINT FR_REMAIN_PROD FOREIGN KEY(REMAIN_PROD) 
                          REFERENCES PROD(PROD_ID)
);
COMMIT;

--데이터의 개수와 컬럼의 개수가 같은 경우
--컬럼을 생략해도 된다
INSERT INTO REMAIN 
VALUES('2003','P101000001',20,10,12,18,'2004-01-01');

--하지만 다음과 같이 컬럼을 명시하는 것을 권장한다.
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_J_00,
                   REMAIN_I,REMAIN_O,REMAIN_J_99,
                   REMAIN_DATE)
VALUES('2003','P101000002',11,7,6,12,'2004-01-02');

SELECT * FROM REMAIN;

COMMIT;

INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_I)
VALUES('2003','P102000007',10);

SELECT * FROM REMAIN;

--NULL값 입력(방법1), INSERT문장의 Column List에서 생략
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_J_00,REMAIN_I
          , REMAIN_J_99,REMAIN_DATE)
VALUES('2003','P102000001',31,21,41,'2003-12-31');
COMMIT;
SELECT * FROM REMAIN;

-- Insert문장의 Value절에서 Null 또는 빈공백(화이트스페이스 - '')으로 지정
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,remain_j_00,REMAIN_I
                  ,remain_o,REMAIN_J_99,REMAIN_DATE)
VALUES('2003','P102000002',31,21,NULL,41,'2003-12-31');

INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,remain_j_00,REMAIN_I
                  ,remain_o,REMAIN_J_99,REMAIN_DATE)
VALUES('2003','P102000003',31,21,'',41,SYSDATE);

COMMIT;
--insert 문제1)
--remain테이블에 다음 데이터를 입력하기
--해당년도 : 2003
--상품코드 : P302000023
--전년재고 : 35
--출고    : 20
--현재고  : 15
--처리일자 : sysdate
INSERT INTO REMAIN(REMAIN_YEAR, REMAIN_PROD,REMAIN_J_00
                  ,REMAIN_O,REMAIN_J_99,REMAIN_DATE )
VALUES ('2003','P302000023',35,20,15,SYSDATE);
COMMIT;
SELECT * FROM REMAIN;

--insert 문제2)
--remain테이블에 다음 데이터를 입력하기
--오류발생 시 상품코드의 첫글자를 수정하여 디버깅
--해당년도 : 2003
--상품코드 : Z302000022 -- 해당 테이블에 해당 데이터가 없으면 INSERT가 안된다.
--전년재고 : 27
--처리일자 : 2004년 1월 1일
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_J_00,REMAIN_DATE)
VALUES ('2003','P302000022',27,'2004-01-01');

--insert 문제3)
--remain테이블에 다음 데이터를 입력하기
--오류발생 시 디버깅(2003년도)
--상품코드 : P302000016
--전년재고 : 30
--입고    : 10
--출고    : 15
--현재고  :25
--처리일자 : 2004년 1월 2일
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_J_00,REMAIN_I,
            REMAIN_O,REMAIN_J_99,REMAIN_DATE)
VALUES ('2003','P302000016',30,10,15,25,'2004-01-02');
COMMIT;

--모든 상품에 대한 재고 수불 파일 생성 ( 2016년도 재고 수불 마감)
--해당년도 : 2017년     
--상품코드 : 전 상품(PROD테이블!!)
--기초(전년)재고 : 상품코드의 우측 2자리를 숫자로 Conversion하여 
--처리 ( 원칙은 전년도말 재고가 되어야 함 )
--입고 : 10으로 일괄 처리
--출고 : 7으로 일괄 처리
--현재고 : 전년재고 + 입고 - 출고
INSERT INTO REMAIN(REMAIN_YEAR,REMAIN_PROD,REMAIN_J_00,REMAIN_I,REMAIN_O,REMAIN_J_99,REMAIN_DATE)
SELECT '2021', PROD_ID, SUBSTR(PROD_ID,-2), 10, 7,  SUBSTR(PROD_ID,-2) + 10 -7, SYSDATE
FROM  PROD;

CREATE TABLE DAWICE(
DW_ACTINFO VARCHAR2(10) NOT NULL,
DW_ACTYEAR VARCHAR2(20) NOT NULL,
DW_MEMBER VARCHAR2(60),
DW_SITE VARCHAR2(40),
CONSTRAINT PK_DAWICE PRIMARY KEY(DW_ACTINFO)
);
COMMIT;

/*
1. DAWICE테이블에 데이터를 입력하기(3명)
DW_ACTINFO : BAEKHYUN
DW_ACTYEAR : 2017
DW_MEMBER  : 변백현
DW_SITE    : http://www.smtown.com
*/
INSERT INTO DAWICE(DW_ACTINFO,DW_ACTYEAR,DW_MEMBER,DW_SITE)
VALUES ('BAEKHYUN','2017','변백현','http://www.smtown.com');
COMMIT;

--문제2) 다음과 같이 3개의 컬럼에 데이터를 입력하기
--DW_ACTINFO : KRIS
--DW_ACTYEAR : 2017
--DW_MEMBER  : 크리스
INSERT INTO DAWICE(DW_ACTINFO,DW_ACTYEAR,DW_MEMBER)
VALUES ('KRIS','2017','크리스');
COMMIT;

--문제3) DAWICE 테이블을 사용하여 
--DAWICE2 테이블을 복제하기(테이블 백업)/기본키,외래키는 복제 안됨
CREATE TABLE DAWICE2
AS
SELECT * FROM DAWICE;
SELECT * FROM DAWICE2;

DESC DAWICE2; --테이블의 구조 보기

--DAWICE2 테이블의 데이터를 삭제
DELETE FROM DAWICE2;
--DAWICE2 테이블의 데이터 조회
SELECT * FROM DAWICE2;

--문제4) DAWICE 테이블을 이용하여
--DAWICE2 테이블로 데이터를 INSERT하기
INSERT INTO DAWICE2(DW_ACTINFO,DW_ACTYEAR)
SELECT DW_ACTINFO,DW_ACTYEAR
FROM   DAWICE;
            
2. SELECT
SELECT [DISTINCT]
FROM <테이블목록>
WHERE <검색조건>
[GROUP BY <열목록>]
[HAVING <검색조건>]
[ORDER BY <열목록>]

SELECT * FROM LPROD
WHERE LPROD > 'P201';

UPDATE 테이블명 SET 필드명1 = 값1, 필드명2 = 값2, ...
WHERE <검색조건>;

--등푸른생선 주세요
SELECT *
FROM LPROD
WHERE LPROD_GU = 'P202';

3. UPDATE
UPDATE LPROD
SET LPROD_NM = '향수'
WHERE LPROD_GU = 'P102'

--업데이트 쎄대여
UPDATE LPROD
SET    LPROD_NM = '향수'
WHERE  LPROD_GU = 'P102';

--'이' 와  '김'씨 성을 가진 회원의 휴대폰 컬럼에 
--'011-111-1111'로 갱신
--업데이트 쎄대여
--데이터가 1000만건 이상이다.
SELECT *
FROM   MEMBER
WHERE  MEM_NAME LIKE '이%' OR MEM_NAME LIKE '김%');
--데이터가 1000만건 미만이다.
SELECT *
FROM   MEMBER
WHERE  SUBSTR(MEM_NAME,1,1) IN('이', '김');

UPDATE MEMBER
SET    MEM_HP = '011-111-1111' --업데이트처리
WHERE  SUBSTR(MEM_NAME,1,1) IN('이', '김'); --조건
--트랜잭션 : 데이터베이스를 변경(I, U, D)하기 위해 
--논리적 기능을 수행하기 위한 일련의 연산 집합으로서 
--작업의 단위이다.
CREATE TABLE A(
   COLI VARCHAR2(30)
); 
--UPDATE,DELETE,INSERT하고나서 커밋하기전
--CREATE를 쓰면 자동으로 COMMIT이 되어버린다.

--회원테이블에서 회원ID가  'a001' 인 회원의 
--데이터를 다음과 같이 수정하시오 ?
--( 취미 : 독서,  직업 : 군인 )
SELECT *
FROM  MEMBER
WHERE MEM_ID = 'a001';

UPDATE MEMBER
SET   MEM_JOB = '군인' , MEM_LIKE = '독서'
WHERE MEM_ID = 'a001';

SELECT * 
FROM   MEMBER
WHERE  SUBSTR(MEM_NAME,1,1) IN ('이','김')
AND    MEM_ID NOT IN('a001','j001');

UPDATE MEMBER
SET    MEM_HP = '099-999-9999'
WHERE  SUBSTR(MEM_NAME,1,1) IN ('이','김')
AND    MEM_ID NOT IN('a001','j001');

4. DELETE 
DELETE FROM 테이블명
WHERE <검색조건>;

DELETE FROM LPROD
WHERE LPROD_GU = 'P202';

/*-------------------------------------------------
--P.시퀀스 보충
/*
 Sequence는 연속, 열거, 순서의 의미.
 Sequence객체는 자동적으로 번호를 생성하기 위한 객체. 
 Sequence객체는 테이블과 독립적이므로 여러 곳에서 사용가능.
 Sequence 를 이용하는 경우 
? Primary Key를 설정할 후보키가 없거나 PK를 특별히 의미 있게 
 만들지 않아도 되는 경우
? 자동으로 순서적인 번호가 필요한 경우
*/
--시퀀스 생성
--START WITH : 시작번호
--INCREMENT BY : 증감
CREATE SEQUENCE LPROD_SEQ --OR REPLACE 없음
INCREMENT BY 1
START WITH 1;

DROP SEQUENCE LPROD_SEQ;
  
--시퀀스 1증가
SELECT LPROD_SEQ.NEXTVAL FROM DUAL;

--현재번호 확인
SELECT LPROD_SEQ.CURRVAL FROM DUAL;
  
--사용방법
CREATE TABLE TESTSEQ(
  TS_ID   NUMBER NOT NULL ,
  TS_NAME VARCHAR2(10),
  CONSTRAINT PK_TESTSEQ PRIMARY KEY(TS_ID)
);

CREATE SEQUENCE TESTSEQ_SEQ
INCREMENT BY 1
START WITH 1;

SELECT * FROM USER_SEQUENCES;  

--ORA-08002: sequence TESTSEQ_SEQ.CURRVAL is not yet defined in this session
SELECT TESTSEQ_SEQ.CURRVAL FROM DUAL; --다음에 만들어야 만들어짐.//현재값

SELECT TESTSEQ_SEQ.NEXTVAL FROM DUAL; --먼저 만들고//증가

--1
SELECT TESTSEQ_SEQ.CURRVAL FROM DUAL;

INSERT INTO TESTSEQ(TS_ID, TS_NAME) 
VALUES(TESTSEQ_SEQ.NEXTVAL,'글1');

INSERT INTO TESTSEQ(TS_ID, TS_NAME) 
VALUES(TESTSEQ_SEQ.NEXTVAL,'글2');

INSERT INTO TESTSEQ(TS_ID, TS_NAME) 
VALUES(TESTSEQ_SEQ.NEXTVAL,'글3');
  
SELECT * FROM TESTSEQ;

commit;

--시퀀스 연습문제
--AOA 테이블 생성
--( NO NUMBER NOT NULL
--, NAME VARCHAR2(30)
--, BIR  VARCHAR2(20))
--NO컬럼을 PRIMARY KEY로 CONSTRAINT하기
CREATE TABLE AOA(
  NO NUMBER NOT NULL ,
  NAME VARCHAR2(30),
  BIR  VARCHAR2(20),
  CONSTRAINT PK_AOA PRIMARY KEY(NO)
);

CREATE SEQUENCE AOA_SEQ
INCREMENT BY 1
START WITH 1;

--시컨스를 사용하여 다음의 데이터를 입력
--1 지민, 1991-01-08 2, 초아 3, 설현 4, 유나 5, 혜정
INSERT INTO AOA(NO, NAME, BIR) 
VALUES(AOA_SEQ.NEXTVAL,'지민','1991-01-08');

INSERT INTO AOA(NO, NAME) 
VALUES(AOA_SEQ.NEXTVAL,'초아');

INSERT INTO AOA(NO, NAME) 
VALUES(AOA_SEQ.NEXTVAL,'설현');

INSERT INTO AOA(NO, NAME) 
VALUES(AOA_SEQ.NEXTVAL,'유나');

INSERT INTO AOA(NO, NAME) 
VALUES(AOA_SEQ.NEXTVAL,'혜정');

SELECT * FROM AOA; 

COMMIT;
 
DROP SEQUENCE AOA_SEQ;

DELETE FROM AOA
WHERE  NO = 5;

/*
Sequence 구문
CREATE SEQUENCE sequence_name
[ START WITH  n ]
[ INCREMENT BY  n ]
[ MAXVALUE n | NOMAXVALUE ]
[ MINVALUE  n | NOMINVALUE ]
[ CYCLE | NOCYCLE ]
[ CACHE n | NOCACHE ]
[ ORDER | NOORDER ]

? Sequence가 사용되는 경우
  - SELECT문의 SELECT 절 (단, SUBQUERY, VIEW가 아닌)
  - INSERT 문의 SELECT 절
  - INSERT 문의 VALUES 절
  - UPDATE문의 SET 절

 ? Sequence가 제한되는 경우
   - SELECT, DELETE, UPDATE 에서의 서브쿼리

 - VIEW의  QUERY구문
   - DISTINCT 가 있는 SELECT 문
   - GROUP BY, ORDER BY 가 있는 SELECT 문
   - SET 연산자(UNION, INTERSECT, MINUS)가 있는 SELECT 문
   - SELECT 문의 WHERE 절
   - CREATE / ALTER TABLE 에서 컬럼의 DEFAULT 값
   - CHECK 제약조건
 */

 
